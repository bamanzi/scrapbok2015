<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width = device-width, initial-scale = 1, user-scalable = no">
		<title>SSH Tricks</title>
		<link type="text/css" rel="stylesheet" href="chrome://isreaditlater/content/text.css">
	</head>
	
	<body o="{&quot;L&quot;:0,&quot;S&quot;:1,&quot;F&quot;:1,&quot;M&quot;:1,&quot;A&quot;:1}" class=" L0 S1 F1 M1 A1" id="less">
	
		<div id="RIL_container"><!--!TOPOFCTN-->
		
	<div id="text_header">
		
			
	<div id="RIL_header">
		
		<div id="RIL_top">
			<!--RILTOP-->
			<cite><span><br><br>Original: </span><a href="https://serversforhackers.com/ssh-tricks" target="_blank">serversforhackers.com/ssh-tricks</a></cite>
			<a class="i" id="RIL_settings"></a>
		</div>
			
		<div id="RIL_settings_wrapper"></div>
		
		<br>
		
		<h1>SSH Tricks</h1>
		<span id="header_cite"><a href="http://serversforhackers.com/">serversforhackers.com</a><span class="RIL_date"><span class="RIL_date_sep"> | </span>Jul 1st 2014</span></span>
	</div>
	
	<div id="text_body">	
		<div><p nodeindex="26">We use SSH to log into our servers, but it actually has a lot of neat tricks it can help us with as well! We'll cover some of them here.</p>

<h2 nodeindex="29">Logging in</h2>
<p nodeindex="30">Of course, we use SSH to login:</p>
<pre nodeindex="31"><code nodeindex="159">$ ssh user@hostname
</code>
</pre>
<p nodeindex="32">And, if needed, we can specify a different port:</p>
<pre nodeindex="33"><code nodeindex="160">$ ssh -p 2222 user@hostname
</code>
</pre>
<p nodeindex="34">Sometimes, if we have a lot of SSH keys in our <code nodeindex="161">~/.ssh</code> directory, we'll often find that SSHing into servers with the intent of using a password results in a "too many authentication attempts" error. If we need to log into a server with a password, we can attempt to force password-based login. This will stop SSH from attempting to use your SSH keys first:</p>
<pre nodeindex="35"><code nodeindex="162">$ ssh -o "PubkeyAuthentication no" username@hostname
</code>
</pre>
<p nodeindex="36">If you use AWS, and in other cases, you might get a PEM file to use as an identity. In this case, you might need to specify a specific identity file to use when logging in. We can do this with the <code nodeindex="163">-i</code> flag:</p>
<pre nodeindex="37"><code nodeindex="164">$ ssh -i /path/to/identity.pem username@hostname
</code>
</pre>
<blockquote nodeindex="38">
<p nodeindex="39">You may need to set your permissions on the pem file so only the owner can read/write/execute it: <code nodeindex="165">chmod 0600 identity.pem</code> or <code nodeindex="166">chmod u+rw identity.pem &amp;&amp; chmod go-rwx identity.pem</code></p>
</blockquote>
<h3 nodeindex="40">SSH Config</h3>
<p nodeindex="41">Here's something really powerful.</p>
<p nodeindex="42">If you want to setup aliases for servers you access often, you can create an <code nodeindex="167">~/.ssh/config</code> file and specify each server you log into, along with the authentication method to use:</p>

<p nodeindex="44">So, there's a few example entries you might find in the <code nodeindex="168">~/.ssh/config</code> file (you can have as many entries as you'd like).</p>
<p nodeindex="45">Using a defined host ("alias") is as easy as this:</p>
<pre nodeindex="46"><code nodeindex="169">$ ssh somealias
</code>
</pre>
<p nodeindex="47">Let's cover the options used above:</p>
<ul nodeindex="49"><li nodeindex="48"><strong nodeindex="170">HostName</strong> - The server host (domain or ipaddress)</li>
<li nodeindex="50"><strong nodeindex="171">Port</strong> - The port to use when connecting</li>
<li nodeindex="51"><strong nodeindex="172">User</strong> - The username to log in with</li>
<li nodeindex="52"><strong nodeindex="173">IdentityFile</strong> - The SSH key identity to use to log in with, if using SSH key access</li>
<li nodeindex="53"><strong nodeindex="174">IdentitiesOnly</strong> - "Yes" to specify only attempting to log in via SSH key</li>
<li nodeindex="54"><strong nodeindex="175">PubkeyAuthentication</strong> - "No" to specify you wish to bypass attempting SSH key authentication</li>
</ul>
<h2 nodeindex="56">SSH Tunneling</h2>
<p nodeindex="57">SSH can be used for tunneling, which is essentially port forwarding. There's a few ways we can do this - Local (Outbound), Remote (Inboud), and some others (Dynamic and Agent Forwarding).</p>
<h3 nodeindex="58">Local Port Forwarding</h3>
<p nodeindex="59">Local port forwarding is what you use when you need to tunnel through a server's firewall or other limitation.</p>
<p nodeindex="60">A common example is attempting to connect to a remote database which is either behind a firewall or is only listening to local connection. For example, MySQL only listens to localhost connections by default. You can't remotely connect to it without editing the <code nodeindex="177">my.cnf</code> file and have it listen on all networks. There's also a firewall preventing you connecting to MySQL's port 3306 anyway.</p>
<blockquote nodeindex="61">
<p nodeindex="62">Remote means any computer that isn't yours, which includes virtual machines (guests) inside of your host computer</p>
</blockquote>
<p nodeindex="63">Assuming we have SSH access to the remote server, we can get around this by creating a tunnel into the server. What might that look like?</p>
<pre nodeindex="64"><code nodeindex="178">ssh -L 3306:localhost:3306 username@hostname
</code>
</pre>
<p nodeindex="65">Let's go over this:</p>
<ul nodeindex="67"><li nodeindex="66"><code nodeindex="179">-L</code> - Setup local port forwarding</li>
<li nodeindex="68"><code nodeindex="180">3306</code> - The local port to forward</li>
<li nodeindex="69"><code nodeindex="181">localhost:3306</code> - Within the remote server, what address and port to forward traffic to. Since the MySQL server is on the remote server, we're tunneling to the remote server's "localhost" on port 3306, which MySQL is listening to.</li>
<li nodeindex="70"><code nodeindex="182">username@localhost</code> - The SSH username and host to connect to</li>
</ul><p nodeindex="71">I can then use my local client to connect to the remote server as if it's a local one:</p>
<!--IMG_1-->
<p nodeindex="73">Now, I used the same port locally and remotely, but I could have specified a different local port to use:</p>
<pre nodeindex="74"><code nodeindex="184">ssh -L 3307:localhost:3306 username@hostname
</code>
</pre>
<p nodeindex="75">Then my local mysql client would have to connect to port <code nodeindex="185">3307</code>, which would still tunnel to the remote server's local <code nodeindex="186">3306</code>:</p>
<!--IMG_2-->
<h3 nodeindex="77">Remote Port Forwarding</h3>
<p nodeindex="78">Remote Port Forwarding is good if you need to share your local computer with others who are outside of your network.</p>
<p nodeindex="79">To do this, we need a remote server all parties can reach. Something like a AWS or Digital Ocean server will do.</p>
<p nodeindex="80">First, let's pretend our local computer has a web server running on port <code nodeindex="188">8001</code>:</p>
<pre nodeindex="81"><code nodeindex="189"># On our local machine:
$ curl localhost:8001
Hi!
</code>
</pre>
<p nodeindex="82">We want our friends to see our website, which simply says "Hi!". Let's use a remote server to forward requests to our local computer:</p>
<pre nodeindex="83"><code nodeindex="190"># Still on our local machine:
ssh -R 9000:localhost:8001 username@hostname
</code>
</pre>
<p nodeindex="84">Let's go over this command:</p>
<ul nodeindex="86"><li nodeindex="85"><code nodeindex="191">-R</code> - Using remote port forwarding</li>
<li nodeindex="87"><code nodeindex="192">9000</code> - The remote server's port to use (not our local server this time!)</li>
<li nodeindex="88"><code nodeindex="193">localhost:8001</code> - The local address to forward to. Since our webserver is on localhost port <code nodeindex="194">8001</code>, that's what we specify here. (Yep, the order of those arguments changed for -R over -L!)</li>
<li nodeindex="89"><code nodeindex="195">username@hostname</code> - SSH access to the remote server</li>
</ul><p nodeindex="90">If our remote server's IP address was <code nodeindex="196">123.123.123.123</code>, then our friends can access our website at <code nodeindex="197">123.123.123.123:9000</code>, which will forward to our local site at <code nodeindex="198">localhost:8001</code>!</p>
<p nodeindex="91"><strong nodeindex="199">Note:</strong> To accomplish this, your remote server's firewall must not block port <code nodeindex="200">9000</code>. You may also need to edit <code nodeindex="201">/etc/ssh/sshd_config</code> and set the <code nodeindex="202">GatewayPorts</code> directive to <code nodeindex="203">yes</code>. (Don't forget to restart SSH after any changes to <code nodeindex="204">sshd_config</code>).</p>

<h2 nodeindex="93">One-Off Commands</h2>
<p nodeindex="94">You can run commands remotely using SSH as well - in fact, this might be the easiest "trick" for using SSH.</p>
<p nodeindex="95">When you run a command using SSH, you're running the command on the remote server. However, any resulting output will be displayed in your terminal.</p>
<p nodeindex="96">Let's just run some simple commands on a remote server. The following will run <code nodeindex="206">pwd</code> command. We'll see that it returns the default folder that we would be in after logging in. The we'll run the <code nodeindex="207">ls</code> command to see the directory's output:</p>

<h3 nodeindex="98">Ansible</h3>
<p nodeindex="99">This is actually the basis of how some server provisioning tools work. In fact, Ansible is very similar - it will run commands over SSH on groups of servers (in series and in parallel).</p>
<p nodeindex="100">Let's see how that works on Ubuntu really quickly.</p>
<p nodeindex="101">First install Ansible on a server that will be doing provisioning (not the one being provisioned):</p>
<pre nodeindex="102"><code nodeindex="208">sudo apt-add-repository -y ppa:rquillo/ansible
sudo apt-get update
sudo apt-get install -y ansible
</code>
</pre>
<p nodeindex="103">Then, configure one or more servers in the <code nodeindex="209">/etc/ansible/hosts</code> directory:</p>
<pre nodeindex="104"><code nodeindex="210">[web]
192.168.22.10
192.168.22.11
192.168.22.12
</code>
</pre>
<p nodeindex="105">Save that file and then let's run a command on all three servers!</p>
<pre nodeindex="106"><code nodeindex="211">$ ansible -k all -m ping -u vagrant
</code>
</pre>
<p nodeindex="107">This will run "ping" on each server. You'll get some JSON output saying if they were successful or not.</p>
<p nodeindex="108">The flags of that command:</p>
<ul nodeindex="110"><li nodeindex="109"><code nodeindex="212">-k</code> - Ask for password</li>
<li nodeindex="111"><code nodeindex="213">all</code> - All servers configured in <code nodeindex="214">/etc/ansible/hosts</code></li>
<li nodeindex="112"><code nodeindex="215">-m ping</code> - Use the ping module</li>
<li nodeindex="113"><code nodeindex="216">-u vagrant</code> - Login with user "vagrant", which will work if the hosts defined are other vagrant servers. Change the username as needed.</li>
</ul><p nodeindex="114">You can actually run any command using the "shell" module:</p>
<pre nodeindex="115"><code nodeindex="217">$ ansible -k all -m shell -u vagrant -a "apt-get install nginx"
</code>
</pre>
<p nodeindex="116">Here, the <code nodeindex="218">-a "apt-get install nginx</code> will run the given command using the "shell" module.</p>
<p nodeindex="117">Here's more information on <a href="http://docs.ansible.com/intro_adhoc.html" nodeindex="219">running ad-hoc commands with Ansible</a>!</p>
</div>
	<div class="clear"></div>
	</div>
	</div>
		</div>
	
	
	<!--!ENDOFPAGE-->
	
	
	
	</body>
</html>
